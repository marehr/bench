;(function(root, factory) {

    if (typeof define === 'function' && define.amd) {
        define(factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else {
        root.BenchmarkExecutor = factory();
    }

})(this, function() {
    const fs = require('fs');
    const process = require('process');
    const path = require('path');

    var self = {};

    /**
     * A list of all output/result files generated by the benchmarks.
     */
    self.result_files = function() {
        var files = [];
        const queue = self.benchmark_queue();
        for (const benchmark of queue) {
            files.push(benchmark.result_file);
        }
        return files;
    };

    var BenchmarkQueue = $.extend([], {
        add_process: function(benchmark_process) {
            this.push($.extend(Object.create(BenchmarkProcess), benchmark_process));
        },

        /**
         * Returns/sets the current executed benchmark.
         *
         * ```
         * // returns the current executed benchmark in the queue
         * var current_process = queue.current_process();
         * ```
         *
         * ```
         * // sets the current executed benchmark
         * var current_process = queue.current_process(queue_id);
         * ```
         *
         * @param  int queue_id The position of the benchmark in the queue.
         * @return BenchmarkProcess
         */
        current_process: function(queue_id) {
            if (queue_id !== undefined) {
                this._queue_id = queue_id;
            }
            return this[this._queue_id];
        },
        total_expected_runtime: function() {
            return this.reduce(function(sum, benchmark_process) {
                return sum + benchmark_process.expected_runtime;
            }, 0);
        },
        total_runtime: function() {
            return this.reduce(function(sum, benchmark_process) {
                return sum + benchmark_process.runtime;
            }, 0);
        }
    });

    var BenchmarkProcess = {
        queue_id: 0,
        benchmark_id: undefined,
        benchmark_name: undefined,
        runtime: undefined,
        expected_runtime: 0,
        threads: 1,

        state: 'QUEUED',
        start_time: undefined,
        result_file: undefined,

        pid: undefined,
        shell_command: '',
        shell_args: [],
        error: undefined,

        getPid: function(){
            return this.pid;
        },
        setPid: function(pid){
            this.pid = pid;
        }
    };

    /**
     * Creates a new benchmark queue and sets it.
     *
     * @return BenchmarkQueue
     */
    self.new_benchmark_queue = function() {
        var queue = Object.create(BenchmarkQueue);
        return self.benchmark_queue(queue);
    };

    /**
     * Returns/sets the benchmarks to execute.
     *
     * ```
     * // returns the benchmark queue
     * var queue = self.benchmark_queue();
     * ```
     *
     * ```
     * // sets the benchmark queue
     * var new_queue = self.benchmark_queue(new_queue);
     * ```
     *
     * @param  BenchmarkQueue queue
     * @return BenchmarkQueue         the current benchmark queue.
     */
    self.benchmark_queue = function(queue) {
        if (queue !== undefined) {
            this._benchmark_queue = queue;
        }
        return this._benchmark_queue;
    };

    self._initialize = function() {
        const shell_parse = require('shell-quote').parse;

        // reset benchmark queue
        var benchmark_queue = self.new_benchmark_queue();
        const max_threads = Configure.system_infos().max_threads;

        _SIGNAL.CANCEL = false;
        _SIGNAL.RUN = true;
        _SIGNAL.DONE = false;

        var queue_id = 0;
        const threads = [1, max_threads];

        // add benchmarks to the benchmark_queue.
        for (var benchmark_id in Configure.benchmarks()) {
            const benchmark = Configure.benchmark(benchmark_id);

            if(!benchmark.execute) {
                continue;
            }

            for (const thread of threads) {
                const core = (thread == 1 ? 'single_core' : 'multi_core');
                var result_file = './results/' + benchmark_id + '.' + core + '.result.txt';

                var shell_args = shell_parse(benchmark.command);
                shell_args.pop();
                shell_args = shell_args.concat([result_file, '-tc', thread]);

                const repeats = benchmark.repeats ? benchmark.repeats : 1;
                for (var i = 0; i < repeats; i++) {
                    const repeat_name = repeats == 1 ? '' : "." + i;
                    const thread_name = " -tc " + thread;

                    benchmark_queue.add_process({
                        queue_id: queue_id++,
                        benchmark_id: benchmark_id,
                        benchmark_name: benchmark_id + repeat_name + thread_name,
                        threads: thread,
                        shell_command: shell_args[0],
                        shell_args: shell_args.slice(1),
                        result_file: result_file,
                        expected_runtime: benchmark.expected_runtime
                    });
                }
            }
        }
    };

    /**
     * Deletes all output files of the executed benchmarks.
     */
    self.clear_results = function(){
        self.result_files().forEach(function(filename){
            fs.exists(filename, function(exists){
                if (!exists) return;
                fs.unlink(path.resolve(filename));
            });
        });
    };

    /**
     * Start the benchmark execution. This will execute all benchmarks in the
     * `benchmark_queue`.
     *
     * @param  callback on_executed will be called after a benchmark
     *                              process completed its execution.
     */
    self.run = function(on_executed){
        self._initialize();
        self.on_executed = on_executed;
        self.clear_results();

        var benchmark_queue = self.benchmark_queue();
        self.benchmark_queue().current_process(0);
        ProgressBar.start(benchmark_queue);

        self._runEach(0);
    };

    /**
     * Converts `process.hrtime` into seconds.
     *
     * @param  array hrtime returned by process.hrtime.
     * @return double
     */
    var to_secs = function(hrtime){
        return hrtime[0] + hrtime[1] * 1e-9;
    };


    /**
     * this handler will be called, if an error occured trying to start a
     * benchmark process or during the excution of the benchmark process.
     *
     * @param Object error error.message contains the error message
     */
    var error_handler = function(error){
        console.error("error_handler: " + error.message);
        var current_process = self.benchmark_queue().current_process();
        _SIGNAL.NORM = false;

        current_process.error = error;
        current_process.state = 'FAILURE';

        eventEmitter.emit(_EVENTS.FAILED);
    };

    /**
     * this handler will be executed after a benchmark process was closed or
     * aborted.
     */
    var executed_handler = function() {
        var current_process = self.benchmark_queue().current_process();
        var queue_id = current_process.queue_id;
        var runtime = process.hrtime(current_process.start_time);
        current_process.runtime = to_secs(runtime);

        if (current_process.state === 'QUEUED') {
            current_process.state = 'SUCCESS';
        }

        // display successful/failed/aborted execution in the gui
        self.on_executed(current_process);
    };

    /**
     * This function executes every benchmark in the queue and does the error
     * handling.
     *
     * @param  int queue_id
     */
    self._runEach = function(queue_id){
        const path = require('path');
        const spawn = require('child_process').spawn;

        // stop if all benchmarks were executed
        if (queue_id >= self.benchmark_queue().length) {
            _SIGNAL.DONE = true;
            eventEmitter.emit(_EVENTS.DONE);
            _SIGNAL.RUN = false;
            return;
        }

        if (_SIGNAL.CANCEL) {
            return _EVENTS.CANCEL;
        }

        // set the current process to be at the current queue_id
        var current_process = self.benchmark_queue().current_process(queue_id);

        // update progress bar
        ProgressBar.update_process(current_process);

        var child_process;

        current_process.start_time = process.hrtime();
        try {
            child_process = spawn(current_process.shell_command, current_process.shell_args, {detached: true});
        } catch(err){
            return error_handler({
                message: err
            });
        }
        current_process.setPid(child_process.pid);
        _SIGNAL.NORM = true;

        // handles process termination
        child_process.on('close', function() {
            executed_handler();

            // execute next benchmark in the queue
            self._runEach(queue_id+1);
        });
        child_process.stdout.on('error', error_handler);
        child_process.stderr.on('error', error_handler);
        child_process.on('error', function(error){
            error_handler({
                message: "Starting program failed: " + error.message
            });
        });
    };

    /**
     * Abort the current running benchmark.
     */
    self.cancel = function(){
        try{
            var current_process = self.benchmark_queue().current_process();
            current_process.state = 'CANCELED';
            process.kill("-" + current_process.getPid());
        } catch(err){
            return err;
        }
        eventEmitter.emit(_EVENTS.CANCEL);
        _SIGNAL.CANCEL = true;
        _SIGNAL.RUN = false;
        _SIGNAL.NORM = false;
        return _EVENTS.CANCEL;
    };

    return self;
});
