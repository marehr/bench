/**
 * BenchmarkExecutor:
 *
 * Events:
 *   'initialize': (benchmark_queue)
 *       Will be called after the benchmark queue was filled and before the
 *       execution of the benchmarks.
 *
 *   'done': (benchmark_queue)
 *       Will be called after the last benchmark was executed.
 *
 *
 *   'setup': (benchmark_process, benchmark_queue)
 *       Will be called before a benchmark will be executed.
 *
 *   'spawned': (process, benchmark_process, benchmark_queue)
 *       Will be called after the benchmark process was started.
 *
 *   'result': (benchmark_process, benchmark_queue)
 *       Will be called after a benchmark terminated. Independent of whether the
 *       benchmark_process was successful, failed or canceled.
 *
 *       ```javascript
 *       benchmark_process.state // either SUCCESS, FAILURE, CANCELED
 *       ```
 *
 *   'error': (benchmark_process, benchmark_queue)
 *       Will be called if an error occured executing the benchmark.
 *
 *   'canceled': (benchmark_process, benchmark_queue)
 *       Will be called after the current running benchmark process was stopped.
 *
 */
;(function(root, factory) {

    if (typeof define === 'function' && define.amd) {
        define(factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else {
        root.BenchmarkExecutor = factory();
    }

})(this, function() {
    const fs = require('fs');
    const process = require('process');
    const path = require('path');
    const EventEmitter = require('events');

    var self = new EventEmitter();

    // at least one listener for the error event, else quote
    // https://nodejs.org/api/events.html#events_error_events:
    //
    // > If an EventEmitter does not have at least one listener registered for
    // > the 'error' event, and an 'error' event is emitted, the error is
    // > thrown, a stack trace is printed, and the Node.js process exits.
    self.on('error', function() {});

    /**
     * A list of all output/result files generated by the benchmarks.
     */
    self.result_files = function() {
        var files = [];
        const queue = self.benchmark_queue();
        for (const benchmark of queue) {
            files.push(benchmark.result_file);
        }
        return files;
    };

    var BenchmarkQueue = $.extend([], {
        add_process: function(benchmark_process) {
            this.push($.extend(Object.create(BenchmarkProcess), benchmark_process));
        },

        /**
         * Returns/sets the current executed benchmark.
         *
         * ```
         * // returns the current executed benchmark in the queue
         * var current_process = queue.current_process();
         * ```
         *
         * ```
         * // sets the current executed benchmark
         * var current_process = queue.current_process(queue_id);
         * ```
         *
         * @param  int queue_id The position of the benchmark in the queue.
         * @return BenchmarkProcess
         */
        current_process: function(queue_id) {
            if (queue_id !== undefined) {
                this._queue_id = queue_id;
            }
            return this[this._queue_id];
        },

        total_expected_runtime: function() {
            return this.reduce(function(sum, benchmark_process) {
                return sum + benchmark_process.expected_runtime;
            }, 0);
        },

        total_runtime: function() {
            return this.reduce(function(sum, benchmark_process) {
                return sum + benchmark_process.runtime;
            }, 0);
        }
    });

    var BenchmarkProcess = {
        queue_id: 0,
        benchmark_id: undefined,
        benchmark_name: undefined,
        runtime: undefined,
        expected_runtime: 0,
        threads: 1,

        state: 'QUEUED',
        start_time: undefined,
        result_file: undefined,

        pid: undefined,
        shell_command: '',
        shell_args: [],
        error: undefined,

        getPid: function(){
            return this.pid;
        },
        setPid: function(pid){
            this.pid = pid;
        }
    };

    /**
     * Creates a new benchmark queue and sets it.
     *
     * @return BenchmarkQueue
     */
    self.new_benchmark_queue = function() {
        var queue = Object.create(BenchmarkQueue);
        return self.benchmark_queue(queue);
    };

    /**
     * Returns/sets the benchmarks to execute.
     *
     * ```
     * // returns the benchmark queue
     * var queue = self.benchmark_queue();
     * ```
     *
     * ```
     * // sets the benchmark queue
     * var new_queue = self.benchmark_queue(new_queue);
     * ```
     *
     * @param  BenchmarkQueue queue
     * @return BenchmarkQueue         the current benchmark queue.
     */
    self.benchmark_queue = function(queue) {
        if (queue !== undefined) {
            this._benchmark_queue = queue;
        }
        return this._benchmark_queue;
    };

    self._initialize = function() {
        const shell_parse = require('shell-quote').parse;

        // reset canceled state
        self.canceled = false;

        // reset benchmark queue
        var benchmark_queue = self.new_benchmark_queue();
        const max_threads = Configure.system_infos().max_threads;

        var queue_id = 0;
        const threads = [1, max_threads];

        // add benchmarks to the benchmark_queue.
        for (var benchmark_id in Configure.benchmarks()) {
            const benchmark = Configure.benchmark(benchmark_id);

            if(!benchmark.execute) {
                continue;
            }

            for (const thread of threads) {
                const core = (thread == 1 ? 'single_core' : 'multi_core');
                var result_file = './results/' + benchmark_id + '.' + core + '.result.txt';

                var shell_args = shell_parse(benchmark.command);
                shell_args.pop();
                shell_args = shell_args.concat([result_file, '-tc', thread]);

                const repeats = benchmark.repeats ? benchmark.repeats : 1;
                for (var i = 0; i < repeats; i++) {
                    const repeat_name = repeats == 1 ? '' : "." + i;
                    const thread_name = " -tc " + thread;

                    benchmark_queue.add_process({
                        queue_id: queue_id++,
                        benchmark_id: benchmark_id,
                        benchmark_name: benchmark_id + repeat_name + thread_name,
                        threads: thread,
                        shell_command: shell_args[0],
                        shell_args: shell_args.slice(1),
                        result_file: result_file,
                        expected_runtime: benchmark.expected_runtime
                    });
                }
            }
        }
    };

    /**
     * Deletes all output files of the executed benchmarks.
     */
    self.clear_results = function(){
        self.result_files().forEach(function(filename){
            fs.exists(filename, function(exists){
                if (!exists) return;
                fs.unlink(path.resolve(filename));
            });
        });
    };

    /**
     * Start the benchmark execution. This will execute all benchmarks in the
     * `benchmark_queue`.
     */
    self.run = function(){
        self._initialize();
        self.clear_results();

        const benchmark_queue = self.benchmark_queue();
        self.benchmark_queue().current_process(0);

        self.emit('initialize', benchmark_queue);

        self._runEach(0);
    };

    /**
     * Converts `process.hrtime` into seconds.
     *
     * @param  array hrtime returned by process.hrtime.
     * @return double
     */
    var to_secs = function(hrtime){
        return hrtime[0] + hrtime[1] * 1e-9;
    };


    /**
     * this handler will be called, if an error occured trying to start a
     * benchmark process or during the excution of the benchmark process.
     *
     * @param Object error error.message contains the error message
     */
    var error_handler = function(error){
        console.error("error_handler: " + error.message);
        var benchmark_queue = self.benchmark_queue();
        var current_process = benchmark_queue.current_process();

        current_process.error = error;
        current_process.state = 'FAILURE';

        self.emit('error', current_process, benchmark_queue);
    };

    /**
     * This function executes every benchmark in the queue and does the error
     * handling.
     *
     * @param  int queue_id
     */
    self._runEach = function(queue_id){
        const path = require('path');
        const spawn = require('child_process').spawn;
        const benchmark_queue = self.benchmark_queue();

        // stop if all benchmarks were executed
        if (queue_id >= benchmark_queue.length) {
            self.emit('done', benchmark_queue);
            return;
        }

        if (self.canceled) {
            return;
        }

        // set the current process to be at the current queue_id
        var current_process = benchmark_queue.current_process(queue_id);
        self.emit('setup', current_process, benchmark_queue);

        var child_process;
        current_process.start_time = process.hrtime();
        try {
            child_process = spawn(current_process.shell_command, current_process.shell_args, {detached: true});
        } catch(err){
            return error_handler({
                message: err
            });
        }
        current_process.setPid(child_process.pid);
        self.emit('spawned', child_process, current_process, benchmark_queue);

        // handles process termination, i.e. this handler will be executed after
        // a benchmark process was closed or aborted.
        child_process.on('close', function() {
            var benchmark_queue = self.benchmark_queue();
            var current_process = benchmark_queue.current_process();
            var runtime = process.hrtime(current_process.start_time);
            var queue_id = current_process.queue_id;
            current_process.runtime = to_secs(runtime);

            if (current_process.state === 'QUEUED') {
                current_process.state = 'SUCCESS';
            }

            // display successful/failed/aborted execution in the gui
            self.emit('result', current_process, benchmark_queue);

            // execute next benchmark in the queue
            self._runEach(queue_id+1);
        });
        child_process.stdout.on('error', error_handler);
        child_process.stderr.on('error', error_handler);
        child_process.on('error', function(error){
            error_handler({
                message: "Starting program failed: " + error.message
            });
        });
    };

    /**
     * Abort the current running benchmark.
     */
    self.cancel = function(){
        var benchmark_queue = self.benchmark_queue();
        var current_process = benchmark_queue.current_process();
        try{
            current_process.state = 'CANCELED';
            self.canceled = true;
            process.kill("-" + current_process.getPid());
        } catch(err){
            console.error(err);
            return err;
        }

        self.emit('canceled', current_process, benchmark_queue);
        return true;
    };

    return self;
});
